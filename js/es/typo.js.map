{"version":3,"file":"typo.js","sources":["../../scratch/main/index.js","../../scratch/main/typo.js"],"sourcesContent":["// BUILD_INCLUDE(\"src/typo/legacy/imports.js\")\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style\n * dictionaries.\n */\nexport class Typo {\n    //#region Constructor\n    /**\n     * Typo constructor.\n     * @param {string} [dictionary] The locale code of the dictionary being used.e.g.,\n     * \"en_US\".This is only used to auto - load dictionaries.\n     * @param {String} [affData] The data from the dictionary 's .aff file. If omitted\n     * and Typo.js is being used in a Chrome extension, the.aff\n     * file will be loaded automatically from\n     * lib / typo / dictionaries / [dictionary] / [dictionary].aff\n     * In other environments,it will be loaded from\n     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].aff\n     * @param {String} [wordsData] The data from the dictionary 's .dic file. If omitted\n     * and Typo.js is being used in a Chrome extension, the.dic\n     * file will be loaded automatically from * lib / typo / dictionaries / [dictionary] / [dictionary].dic\n     * In other environments, it will be loaded from\n     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].dic\n     * @param {Object} [settings] Constructor settings.Available properties are :\n     * {String}[dictionaryPath] : path to load dictionary from in non - chrome\n     * environment.\n     * {Object}[flags] : flag information.\n     * {Boolean}[asyncLoad] : If true, affData and wordsData will be loaded\n     * asynchronously.\n     * {Function}[loadedCallback] : Called when both affData and wordsData\n     * have been loaded.Only used if asyncLoad is set to true.The parameter\n     * is the instantiated Typo object.\n     */\n    constructor(dictionary, affData, wordsData, settings) {\n        this.ERR_NOT_LOAD = \"Dictionary not loaded\";\n        this.ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n        this.lDictionary = '';\n        /**\n        * Object that will contain and entry of IRuleCodes for each\n        * dynamically added key\n        */\n        this.rules = {};\n        // dictionaryTable seems to be an object full or arrays for elements in the dom.\n        this.dictionaryTable = {};\n        this.compoundRules = [];\n        this.compoundRuleCodes = {};\n        this.replacementTable = new Array();\n        this.memoized = {};\n        this.loaded = false;\n        this.options = settings || { flags: {} };\n        if (settings !== undefined && settings !== null) {\n            if (settings.flags !== undefined) {\n                this.flags = settings.flags;\n            }\n            else {\n                this.flags = {};\n            }\n        }\n        else {\n            this.flags = {};\n        }\n        const readDataFile = (url) => {\n            const response = this._readFile(url, null);\n            return response;\n            // response.then(text => {\n            // \tsetFunc(text);\n            // }).catch(error => {\n            // \tconsole.error(error);\n            // });\n        };\n        const init = async (dic, aff, wData) => {\n            const setAffData = (data) => {\n                aff = data;\n                if (wData) {\n                    setup();\n                }\n            };\n            const setWordsData = (data) => {\n                wData = data;\n                if (aff) {\n                    setup();\n                }\n            };\n            const setup = () => {\n                if (!aff) {\n                    return;\n                }\n                if (!wData) {\n                    return;\n                }\n                this.rules = this._parseAFF(aff);\n                // Save the rule codes that are used in compound rules.\n                this.compoundRuleCodes = {};\n                for (const rule of this.compoundRules) {\n                    if (typeof rule === 'string') {\n                        for (let j = 0; j < rule.length; j++) {\n                            this.compoundRuleCodes[rule.charAt(j)] = [];\n                        }\n                    }\n                }\n                // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n                // will do the work of saving the list of words that are compound-only.\n                if (this.flags.ONLYINCOMPOUND) {\n                    this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = [];\n                }\n                this.dictionaryTable = this._parseDIC(wData);\n                // Get rid of any codes from the compound rule codes that are never used\n                // (or that were special regex characters).  Not especially necessary...\n                for (const iKey in this.compoundRuleCodes) {\n                    if (Object.prototype.hasOwnProperty.call(this.compoundRuleCodes, iKey)) {\n                        if (this.compoundRuleCodes[iKey].length === 0) {\n                            delete this.compoundRuleCodes[iKey];\n                        }\n                    }\n                }\n                // Build the full regular expressions for each compound rule.\n                // I have a feeling (but no confirmation yet) that this method of\n                // testing for compound words is probably slow.\n                i = 0;\n                for (const ruleText of this.compoundRules) {\n                    let expressionText = \"\";\n                    if (typeof ruleText === 'string') {\n                        for (const character of ruleText) {\n                            if (character in this.compoundRuleCodes) {\n                                expressionText += \"(\" + this.compoundRuleCodes[character].join(\"|\") + \")\";\n                            }\n                            else {\n                                expressionText += character;\n                            }\n                        }\n                        this.compoundRules[i] = new RegExp(expressionText, \"i\");\n                        i++;\n                    }\n                }\n            };\n            const isChromeExt = () => {\n                if (typeof window.chrome?.runtime?.getURL === 'function') {\n                    return true;\n                }\n                return false;\n            };\n            const isBrowserExt = () => {\n                if (typeof window.browser?.runtime?.getURL === 'function') {\n                    return true;\n                }\n                return false;\n            };\n            let path;\n            let pLoadDataAff;\n            let pLoadDataDic;\n            // Loop-control variables.\n            let i;\n            if (dic) {\n                this.lDictionary = dic;\n                // If the data is preloaded, just setup the Typo object.\n                if (aff && wData) {\n                    setup();\n                }\n                // Loading data for Browser extentions.\n                else if (typeof window !== 'undefined' && (isChromeExt() === true || isBrowserExt() === true)) {\n                    if (this.options.dictionaryPath) {\n                        path = this.options.dictionaryPath;\n                    }\n                    else {\n                        path = \"typo/dictionaries\";\n                    }\n                    let getURL;\n                    if (isChromeExt() === true) {\n                        getURL = window.chrome.runtime.getURL;\n                    }\n                    else {\n                        getURL = window.browser.runtime.getURL;\n                    }\n                    if (!aff) {\n                        pLoadDataAff = readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".aff\"))\n                            .then(affD => {\n                            setAffData(affD);\n                        });\n                    }\n                    if (!wData) {\n                        pLoadDataDic = readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".dic\"))\n                            .then(wordsD => {\n                            setWordsData(wordsD);\n                        });\n                    }\n                }\n                else {\n                    if (this.options.dictionaryPath) {\n                        path = this.options.dictionaryPath;\n                    }\n                    else if (typeof __dirname !== 'undefined') {\n                        path = __dirname + '/dictionaries';\n                    }\n                    else {\n                        path = './dictionaries';\n                    }\n                    if (!aff) {\n                        pLoadDataAff = readDataFile(path + \"/\" + dic + \"/\" + dic + \".aff\")\n                            .then(affD => {\n                            setAffData(affD);\n                        });\n                    }\n                    if (!wData) {\n                        pLoadDataDic = readDataFile(path + \"/\" + dic + \"/\" + dic + \".dic\")\n                            .then(wordsD => {\n                            setWordsData(wordsD);\n                        });\n                    }\n                }\n            }\n            return new Promise((resolve, reject) => {\n                Promise.all([pLoadDataDic, pLoadDataAff])\n                    .then(() => { resolve(true); })\n                    .catch(err => { reject(err); });\n            });\n        };\n        this.readyPromise = new Promise((resolve, reject) => {\n            init(dictionary, affData, wordsData)\n                .then(() => {\n                resolve(this);\n            })\n                .catch((err) => {\n                reject(err);\n            });\n        });\n        if (this.options.loadedCallback) {\n            this.ready.then();\n        }\n    }\n    //#endregion Constructor\n    //#region  Properties\n    get ready() {\n        const doCallBacks = (err, t) => {\n            if (this.options.loadedCallback) {\n                if (typeof this.options.loadedCallback === 'function') {\n                    this.options.loadedCallback(err, t);\n                }\n                else if (typeof this.options.loadedCallback === 'object') {\n                    this.options.loadedCallback.forEach(fn => {\n                        fn(err, t);\n                    });\n                }\n            }\n        };\n        return this.readyPromise.then(() => {\n            this.loaded = true; // store the result\n            doCallBacks(null, this);\n            return this; // this is what makes the one-liner possible!\n        })\n            .catch(err => {\n            doCallBacks(err, this);\n            throw err;\n        });\n    }\n    get dictionary() {\n        if (this.lDictionary === '') {\n            return null;\n        }\n        return this.lDictionary;\n    }\n    //#endregion properties\n    /**\n     * Loads a Typo instance from a hash of all of the Typo properties.\n     *\n     * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n     */\n    load(obj) {\n        for (const i in obj) {\n            if (obj.hasOwnProperty(i) && Object(this).hasOwnProperty(i)) {\n                const val = obj[i];\n                Object.defineProperty(this, i.toString(), {\n                    value: val,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n                // this[i] = obj[i];\n            }\n        }\n        return this;\n    }\n    //#region check Methods\n    /**\n     * Checks whether a word or a capitalization variant exists in the current dictionary.\n     * The word is trimmed and several variations of capitalizations are checked.\n     * If you want to check a word without any changes made to it, call checkExact()\n     *\n     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n     *\n     * @param {string} aWord The word to check.\n     * @returns {boolean}\n     */\n    check(aWord) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (aWord.length === 0) {\n            return false;\n        }\n        // Remove leading and trailing whitespace\n        const trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n        if (this.checkExact(trimmedWord)) {\n            return true;\n        }\n        // The exact word is not in the dictionary.\n        if (trimmedWord.toUpperCase() === trimmedWord) {\n            // The word was supplied in all uppercase.\n            // Check for a capitalized form of the word.\n            const capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n            if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) { // Capitalization variants are not allowed for this word.\n                return false;\n            }\n            if (this.checkExact(capitalizedWord)) {\n                return true;\n            }\n        }\n        const lowercaseWord = trimmedWord.toLowerCase();\n        if (lowercaseWord !== trimmedWord) {\n            if (this.hasFlag(lowercaseWord, \"KEEPCASE\")) { // Capitalization variants are not allowed for this word.\n                return false;\n            }\n            // Check for a lowercase form\n            if (this.checkExact(lowercaseWord)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    //#endregion\n    //#region checkExact method\n    /**\n    * Checks whether a word exists in the current dictionary.\n    *\n    * @param {string} word The word to check.\n    * @returns {boolean}\n    */\n    checkExact(word) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (word.length === 0) {\n            return false;\n        }\n        const ruleCodes = this.dictionaryTable[word];\n        if (typeof ruleCodes === 'undefined') { // Check if this might be a compound word.\n            if ((this.flags.COMPOUNDMIN) && (word.length >= this.flags.COMPOUNDMIN)) {\n                for (const rule of this.compoundRules) {\n                    if (word.match(rule)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        else if (ruleCodes === null) {\n            // a null (but not undefined) value for an entry in the dictionary table\n            // means that the word is in the dictionary but has no flags.\n            return true;\n        }\n        else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n            for (const ruleCode of ruleCodes) {\n                if ((ruleCode !== null)\n                    && !(this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCode))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    //#endregion\n    //#region hasFlag\n    /**\n     * Looks up whether a given word is flagged with a given flag.\n     *\n     * @param {string} word The word in question.\n     * @param {string} strFlag The flag in question.\n     * @param {any} [wordFlags]\n     * @return {boolean}\n     */\n    hasFlag(word, strFlag, wordFlags) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        const flattenArr = (arr) => {\n            const ar = [];\n            for (const a of arr) {\n                for (const s of a) {\n                    ar.push(s);\n                }\n            }\n            return ar;\n        };\n        if (strFlag in this.flags) {\n            if (typeof wordFlags === 'undefined') {\n                const tableItem = this.dictionaryTable[word];\n                if (tableItem !== undefined && tableItem !== null) {\n                    wordFlags = flattenArr(tableItem); // only interested in index of a key\n                }\n                else {\n                    wordFlags = [];\n                }\n            }\n            if (wordFlags && wordFlags.indexOf(this.flags[strFlag]) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    //#endregion hasFlag\n    //#region suggest method\n    /**\n    * Returns a list of suggestions for a misspelled word.\n    *\n    * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n    * This suggestor is primitive, but it works.\n    *\n    * @param {string} word The misspelling.\n    * @param {number} [limit=5] The maximum number of suggestions to return.\n    * @returns {string[]} The array of suggestions.\n    */\n    suggest(word, limit = 5) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (this.memoized.hasOwnProperty(word)) {\n            const memoizedLimit = this.memoized[word]['limit'];\n            // Only return the cached list if it's big enough or if there weren't enough suggestions\n            // to fill a smaller limit.\n            if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n                return this.memoized[word]['suggestions'].slice(0, limit);\n            }\n        }\n        if (this.check(word)) {\n            return [];\n        }\n        // Check the replacement table.\n        for (const replacementEntry of this.replacementTable) {\n            if (word.indexOf(replacementEntry[0]) !== -1) {\n                const correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n                if (this.check(correctedWord)) {\n                    return [correctedWord];\n                }\n            }\n        }\n        /*\n        if (!self.alphabet) {\n            // Use the alphabet as implicitly defined by the words in the dictionary.\n            var alphaHash = {};\n            \n            for (var i in self.dictionaryTable) {\n                for (var j = 0, _len = i.length; j < _len; j++) {\n                    alphaHash[i[j]] = true;\n                }\n            }\n            \n            for (var i in alphaHash) {\n                self.alphabet += i;\n            }\n            \n            var alphaArray = self.alphabet.split(\"\");\n            alphaArray.sort();\n            self.alphabet = alphaArray.join(\"\");\n        }\n        */\n        /**\n         * Returns a hash keyed by all of the strings that can be made\n         * by making a single edit to the word (or words in) `words`\n         * The value of each entry is the number of unique ways that the\n         * resulting word can be made.\n         * @param words words Either a hash keyed by words or a string word to operate on.\n         * @param {boolean} [knownOnly=false] known_only Whether this function should ignore strings that are not in the dictionary.\n         */\n        const edits1 = (words, knownOnly = false) => {\n            const rv = {};\n            let i;\n            let j;\n            let numLen;\n            let numJlen;\n            let strEdit;\n            if (typeof words === 'string') {\n                const wrd = words;\n                words = {};\n                words[wrd] = 1;\n            }\n            for (const wrd in words) {\n                if (Object.prototype.hasOwnProperty.call(words, wrd)) {\n                    // const wd = words[wd];\n                    for (i = 0, numLen = wrd.length + 1; i < numLen; i++) {\n                        const strSub = [wrd.substring(0, i), wrd.substring(i)];\n                        if (strSub[1]) {\n                            strEdit = strSub[0] + strSub[1].substring(1);\n                            if (!knownOnly || this.check(strEdit)) {\n                                if (!(strEdit in rv)) {\n                                    rv[strEdit] = 1;\n                                }\n                                else {\n                                    rv[strEdit] += 1;\n                                }\n                            }\n                        }\n                        // Eliminate transpositions of identical letters\n                        if (strSub[1].length > 1 && strSub[1][1] !== strSub[1][0]) {\n                            strEdit = strSub[0] + strSub[1][1] + strSub[1][0] + strSub[1].substring(2);\n                            if (!knownOnly || this.check(strEdit)) {\n                                if (!(strEdit in rv)) {\n                                    rv[strEdit] = 1;\n                                }\n                                else {\n                                    rv[strEdit] += 1;\n                                }\n                            }\n                        }\n                        if (strSub[1]) {\n                            for (j = 0, numJlen = this.ALPHABET.length; j < numJlen; j++) {\n                                // Eliminate replacement of a letter by itself\n                                if (this.ALPHABET[j] !== strSub[1].substring(0, 1)) {\n                                    strEdit = strSub[0] + this.ALPHABET[j] + strSub[1].substring(1);\n                                    if (!knownOnly || this.check(strEdit)) {\n                                        if (!(strEdit in rv)) {\n                                            rv[strEdit] = 1;\n                                        }\n                                        else {\n                                            rv[strEdit] += 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (strSub[1]) {\n                            for (j = 0, numJlen = this.ALPHABET.length; j < numJlen; j++) {\n                                strEdit = strSub[0] + this.ALPHABET[j] + strSub[1];\n                                if (!knownOnly || this.check(strEdit)) {\n                                    if (!(strEdit in rv)) {\n                                        rv[strEdit] = 1;\n                                    }\n                                    else {\n                                        rv[strEdit] += 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return rv;\n        };\n        const correct = (wrd) => {\n            // Get the edit-distance-1 and edit-distance-2 forms of this word.\n            const ed1 = edits1(wrd);\n            const ed2 = edits1(ed1, true);\n            // Sort the edits based on how many different ways they were created.\n            const weightedCorrections = ed2;\n            for (const ed1word in ed1) {\n                if (!this.check(ed1word)) {\n                    continue;\n                }\n                if (ed1word in weightedCorrections) {\n                    weightedCorrections[ed1word] += ed1[ed1word];\n                }\n                else {\n                    weightedCorrections[ed1word] = ed1[ed1word];\n                }\n            }\n            let i;\n            const sortedCorrections = [];\n            for (const j in weightedCorrections) {\n                // if (Object.prototype.hasOwnProperty.call(weighted_corrections, i)) {\n                // \tsorted_corrections.push([i, weighted_corrections[i]]);\n                // }\n                if (weightedCorrections.hasOwnProperty(j)) {\n                    sortedCorrections.push([j, weightedCorrections[j]]);\n                }\n            }\n            const sorter = (a, b) => {\n                // frist eleement is the word if a and b\n                // second element of a and b is numeric values\n                const aVal = a[1];\n                const bVal = b[1];\n                if (aVal < bVal) {\n                    return -1;\n                }\n                else if (aVal > bVal) {\n                    return 1;\n                }\n                // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n                return b[0].toString().localeCompare(a[0].toString());\n            };\n            sortedCorrections.sort(sorter).reverse();\n            const rv = [];\n            let capitalizationScheme = \"lowercase\";\n            if (wrd.toUpperCase() === wrd) {\n                capitalizationScheme = \"uppercase\";\n            }\n            else if (wrd.substr(0, 1).toUpperCase() + wrd.substr(1).toLowerCase() === wrd) {\n                capitalizationScheme = \"capitalized\";\n            }\n            let workingLimit = limit;\n            for (i = 0; i < Math.min(workingLimit, sortedCorrections.length); i++) {\n                let sortString = sortedCorrections[i][0].toString();\n                let update = false;\n                if (\"uppercase\" === capitalizationScheme) {\n                    sortString = sortString.toUpperCase();\n                    update = true;\n                }\n                else if (\"capitalized\" === capitalizationScheme) {\n                    sortString = sortString.substr(0, 1).toUpperCase() + sortString.substr(1);\n                    update = true;\n                }\n                if (!this.hasFlag(sortString, \"NOSUGGEST\") && rv.indexOf(sortString) === -1) {\n                    rv.push(sortString);\n                }\n                else {\n                    // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n                    workingLimit++;\n                }\n                if (update) {\n                    sortedCorrections[i][0] = sortString;\n                }\n            }\n            return rv;\n        };\n        this.memoized[word] = {\n            'suggestions': correct(word),\n            'limit': limit\n        };\n        return this.memoized[word]['suggestions'];\n    }\n    //#endregion suggest\n    // #region _removeAffixComments\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from an affix file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeAffixComments(data) {\n        // Remove comments\n        // This used to remove any string starting with '#' up to the end of the line,\n        // but some COMPOUNDRULE definitions include '#' as part of the rule.\n        // I haven't seen any affix files that use comments on the same line as real data,\n        // so I don't think this will break anything.\n        const str = data.replace(/^\\s*#.*$/mg, \"\")\n            // Trim each line\n            .replace(/^\\s\\s*/m, '')\n            .replace(/\\s\\s*$/m, '')\n            // Remove blank lines.\n            .replace(/\\n{2,}/g, \"\\n\")\n            // Trim the entire string\n            .replace(/^\\s\\s*/, '')\n            .replace(/\\s\\s*$/, '');\n        return str;\n    }\n    // #endregion _removeAffixComments\n    // #region _readFile function\n    /**\n     * Read the contents of a file.\n     *\n     * @param {String} path The path (relative) to the file.\n     * @param {String|null} charset The expected charset of the file, If null default to utf8\n     * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n     * files are read synchronously.\n     * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n     * always returned.\n     */\n    _readFile(path, charset) {\n        charset = charset || \"utf8\";\n        if (typeof window !== 'undefined') {\n            const requestHeaders = new Headers();\n            requestHeaders.set('Content-Type', \"text/plain; charset=\" + charset);\n            return fetch(path, {\n                method: 'GET',\n                headers: requestHeaders\n            }).then((response) => {\n                return response.text();\n            });\n            ;\n        }\n        return Promise.reject(new Error('An Error occured getting dictionary'));\n    }\n    // #endregion _readFile function\n    // #region _parseAFF\n    _parseAFF(data) {\n        const rules = {};\n        let line;\n        let subline;\n        let numEntries;\n        let lineParts;\n        let i;\n        let j = 0;\n        let iLen = 0;\n        let jLen = 0;\n        // Remove comment lines\n        data = this._removeAffixComments(data);\n        const lines = data.split(/\\r?\\n/);\n        iLen = lines.length;\n        for (i = 0; i < iLen; i++) {\n            line = lines[i];\n            const definitionParts = line.split(/\\s+/);\n            const ruleType = definitionParts[0].toUpperCase();\n            if (ruleType === \"PFX\" || ruleType === \"SFX\") {\n                const ruleCode = definitionParts[1];\n                const combineable = definitionParts[2].toUpperCase();\n                numEntries = parseInt(definitionParts[3], 10);\n                const entries = [];\n                if (isNaN(numEntries) === false) {\n                    for (j = i + 1, jLen = i + 1 + numEntries; j < jLen; j++) {\n                        subline = lines[j];\n                        lineParts = subline.split(/\\s+/);\n                        const charactersToRemove = lineParts[2];\n                        const additionParts = lineParts[3].split(\"/\");\n                        let charactersToAdd = additionParts[0];\n                        if (charactersToAdd === \"0\") {\n                            charactersToAdd = \"\";\n                        }\n                        const continuationClasses = this.parseRuleCodes(additionParts[1]);\n                        const regexToMatch = lineParts[4];\n                        const entry = {\n                            add: charactersToAdd\n                        };\n                        if (continuationClasses.length > 0) {\n                            entry.continuationClasses = continuationClasses;\n                        }\n                        if (regexToMatch !== \".\") {\n                            if (ruleType === \"SFX\") {\n                                entry.match = new RegExp(regexToMatch + \"$\");\n                            }\n                            else {\n                                entry.match = new RegExp(\"^\" + regexToMatch);\n                            }\n                        }\n                        if (charactersToRemove.toString() !== \"0\") {\n                            if (ruleType === \"SFX\") {\n                                entry.remove = new RegExp(charactersToRemove + \"$\");\n                            }\n                            else {\n                                // in original Typo.js this was added as string\n                                // entry.remove = charactersToRemove;\n                                entry.remove = new RegExp(charactersToRemove);\n                            }\n                        }\n                        entries.push(entry);\n                    }\n                }\n                rules[ruleCode] = {\n                    \"type\": ruleType,\n                    \"combineable\": (combineable === \"Y\"),\n                    \"entries\": entries\n                };\n                i += numEntries;\n            }\n            else if (ruleType === \"COMPOUNDRULE\") {\n                numEntries = parseInt(definitionParts[1], 10);\n                for (j = i + 1, jLen = i + 1 + numEntries; j < jLen; j++) {\n                    line = lines[j];\n                    lineParts = line.split(/\\s+/);\n                    // When the regexp parameter is a string or a number,\n                    // it is implicitly converted to a RegExp by using new RegExp(regexp).\n                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\n                    this.compoundRules.push(lineParts[1]);\n                }\n                i += numEntries;\n            }\n            else if (ruleType === \"REP\") {\n                lineParts = line.split(/\\s+/);\n                if (lineParts.length === 3) {\n                    this.replacementTable.push([\n                        lineParts[1], lineParts[2]\n                    ]);\n                }\n            }\n            else {\n                // ONLYINCOMPOUND\n                // COMPOUNDMIN\n                // FLAG\n                // KEEPCASE\n                // NEEDAFFIX\n                this.flags[ruleType] = definitionParts[1];\n            }\n        }\n        return rules;\n    }\n    // #endregion _parseAFF\n    // #region _parseDIC\n    /**\n     * Parses the words out from the .dic file.\n     *\n     * @param {String} data The data from the dictionary file.\n     * @returns object The lookup table containing all of the words and\n     *                 word forms from the dictionary.\n    * The dictionary table looks similar to the folowng.\n    * Note the dictionary table can have more than 20,000 entries\n    ````js\n        var dictionaryTable = {\n            \"1\": [[\"n\", \"m\"]],\n            \"2\": [[\"n\", \"1\"]],\n            \"d\": [[\"J\", \"G\", \"V\", \"X\"]]\n            };\n     ````\n     */\n    _parseDIC(data) {\n        data = this._removeDicComments(data);\n        const lines = data.split(/\\r?\\n/);\n        const dictionaryTable = {};\n        /**\n         * Pushes a string array on dictionary table\n         * @param {strng} key The key to add or append rules to\n         * @param {string[]} rules string array of rules to add.\n         *\n         * The dictionary table looks similar to the folowng.\n         * Note the dictionary table can have more than 20,000 entries\n         ```js\n        var dictionaryTable = {\n            \"1\": [[\"n\", \"m\"]],\n            \"2\": [[\"n\", \"1\"]],\n            \"d\": [[\"J\", \"G\", \"V\", \"X\"]]\n            };\n         ```\n         */\n        const addWord = (key, rules) => {\n            if (!dictionaryTable.hasOwnProperty(key)) {\n                dictionaryTable[key] = null;\n            }\n            if (rules.length > 0) {\n                let el = dictionaryTable[key];\n                if (el === null || el === undefined) {\n                    el = [];\n                    dictionaryTable[key] = el;\n                }\n                el.push(rules);\n            }\n        };\n        // The first line is the number of words in the dictionary.\n        for (let i = 1; i < lines.length; i++) {\n            const line = lines[i];\n            if (!line) { // Ignore empty lines.\n                continue;\n            }\n            const parts = line.split(\"/\", 2);\n            const word = parts[0];\n            // Now for each affix rule, generate that form of the word.\n            if (parts.length > 1) {\n                const ruleCodesArray = this.parseRuleCodes(parts[1]);\n                // Save the ruleCodes for compound word situations.\n                if (!(this.flags.NEEDAFFIX)\n                    || (this.flags.NEEDAFFIX && ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1)) {\n                    addWord(word, ruleCodesArray);\n                }\n                const jlen = ruleCodesArray.length;\n                for (let j = 0; j < jlen; j++) {\n                    const code = ruleCodesArray[j];\n                    const rule = this.rules[code];\n                    if (rule) {\n                        const newWords = this._applyRule(word, rule);\n                        for (const newWord of newWords) {\n                            addWord(newWord, []);\n                            if (rule.combineable) {\n                                for (let k = j + 1; k < jlen; k++) {\n                                    const combineCode = ruleCodesArray[k];\n                                    const combineRule = this.rules[combineCode];\n                                    if (combineRule) {\n                                        if (combineRule.combineable && (rule.type !== combineRule.type)) {\n                                            const otherNewWords = this._applyRule(newWord, combineRule);\n                                            for (const otherNewWord of otherNewWords) {\n                                                addWord(otherNewWord, []);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (code in this.compoundRuleCodes) {\n                        this.compoundRuleCodes[code].push(word);\n                    }\n                }\n            }\n            else {\n                addWord(word.trim(), []);\n            }\n        }\n        return dictionaryTable;\n    }\n    // #endregion _parseDIC\n    // #region _removeDicComments\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from a .dic file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeDicComments(data) {\n        // I can't find any official documentation on it, but at least the de_DE\n        // dictionary uses tab-indented lines as comments.\n        // Remove comments\n        return data.replace(/^\\t.*$/mg, \"\");\n    }\n    // #endregion _removeDicComments\n    // #region _applyRule\n    _applyRule(word, rule) {\n        const entries = rule.entries;\n        let newWords = [];\n        // if (!entries) {\n        // \treturn newWords;\n        // }\n        for (const entry of entries) {\n            if (!entry.match || word.match(entry.match)) {\n                let newWord = word;\n                if (entry.remove) {\n                    newWord = newWord.replace(entry.remove, \"\");\n                }\n                if (rule.type === \"SFX\") {\n                    newWord = newWord + entry.add;\n                }\n                else {\n                    newWord = entry.add + newWord;\n                }\n                newWords.push(newWord);\n                if (entry.continuationClasses) {\n                    entry.continuationClasses.map(key => {\n                        const continuationRule = this.rules[key];\n                        if (continuationRule) {\n                            newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n                        }\n                        /*\n                    else {\n                        // This shouldn't happen, but it does, at least in the de_DE dictionary.\n                        // I think the author mistakenly supplied lower-case rule codes instead\n                        // of upper-case.\n                    }\n                    */\n                    });\n                }\n            }\n        }\n        return newWords;\n    }\n    // #endregion _applyRule\n    //#region init\n    //#endregion init\n    // #region parseRuleCodes\n    /**\n     *\n     * @param {string} textCodes\n     */\n    parseRuleCodes(textCodes) {\n        if (!textCodes || this.flags === undefined) {\n            return [];\n        }\n        else if (!(this.flags.FLAG)) {\n            return textCodes.split(\"\");\n        }\n        else if (this.flags.FLAG === \"long\") {\n            const pFlags = [];\n            for (let i = 0; i < textCodes.length; i += 2) {\n                pFlags.push(textCodes.substr(i, 2));\n            }\n            return pFlags;\n        }\n        else if (this.flags.FLAG === \"num\") {\n            return textCodes.split(\",\");\n        }\n        return [];\n    }\n}\n","import { Typo as T } from './index';\nif (typeof window !== 'undefined' && window.Typo === undefined) {\n    window.Typo = T;\n}\n"],"names":["Typo","dictionary","affData","wordsData","settings","ERR_NOT_LOAD","ALPHABET","lDictionary","rules","dictionaryTable","compoundRules","compoundRuleCodes","replacementTable","Array","memoized","loaded","options","flags","undefined","readDataFile","url","response","_readFile","init","dic","aff","wData","setAffData","data","setup","setWordsData","_parseAFF","rule","j","length","charAt","ONLYINCOMPOUND","_parseDIC","iKey","Object","prototype","hasOwnProperty","call","i","ruleText","expressionText","character","join","RegExp","isChromeExt","window","chrome","runtime","getURL","isBrowserExt","browser","path","pLoadDataAff","pLoadDataDic","dictionaryPath","then","affD","wordsD","__dirname","Promise","resolve","reject","all","catch","err","readyPromise","loadedCallback","ready","obj","val","defineProperty","toString","value","writable","enumerable","configurable","aWord","Error","trimmedWord","replace","checkExact","toUpperCase","capitalizedWord","substring","toLowerCase","hasFlag","lowercaseWord","word","ruleCodes","COMPOUNDMIN","match","ruleCode","strFlag","wordFlags","flattenArr","arr","ar","a","s","push","tableItem","indexOf","limit","memoizedLimit","slice","check","replacementEntry","correctedWord","edits1","words","knownOnly","rv","numLen","numJlen","strEdit","wrd","strSub","correct","ed1","ed2","weightedCorrections","ed1word","sortedCorrections","sorter","b","aVal","bVal","localeCompare","sort","reverse","capitalizationScheme","substr","workingLimit","Math","min","sortString","update","str","charset","requestHeaders","Headers","set","fetch","method","headers","text","line","subline","numEntries","lineParts","iLen","jLen","_removeAffixComments","lines","split","definitionParts","ruleType","combineable","parseInt","entries","isNaN","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","remove","_removeDicComments","addWord","key","el","parts","ruleCodesArray","NEEDAFFIX","jlen","code","newWords","_applyRule","newWord","k","combineCode","combineRule","type","otherNewWords","otherNewWord","trim","map","continuationRule","concat","textCodes","FLAG","pFlags","doCallBacks","t","forEach","fn","T"],"mappings":"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"}
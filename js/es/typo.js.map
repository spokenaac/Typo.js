{"version":3,"file":"typo.js","sources":["../../scratch/main/index.js","../../scratch/main/typo.js"],"sourcesContent":["// BUILD_INCLUDE(\"typo/legacy/imports.js\")\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style\n * dictionaries.\n */\nexport class Typo {\n    //#region Constructor\n    /**\n     * Typo constructor.\n     * @param {string} [dictionary] The locale code of the dictionary being used.e.g.,\n     * \"en_US\".This is only used to auto - load dictionaries.\n     * @param {String} [affData] The data from the dictionary 's .aff file. If omitted\n     * and Typo.js is being used in a Chrome extension, the.aff\n     * file will be loaded automatically from\n     * lib / typo / dictionaries / [dictionary] / [dictionary].aff\n     * In other environments,it will be loaded from\n     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].aff\n     * @param {String} [wordsData] The data from the dictionary 's .dic file. If omitted\n     * and Typo.js is being used in a Chrome extension, the.dic\n     * file will be loaded automatically from * lib / typo / dictionaries / [dictionary] / [dictionary].dic\n     * In other environments, it will be loaded from\n     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].dic\n     * @param {Object} [settings] Constructor settings.Available properties are :\n     * {String}[dictionaryPath] : path to load dictionary from in non - chrome\n     * environment.\n     * {Object}[flags] : flag information.\n     * {Boolean}[asyncLoad] : If true, affData and wordsData will be loaded\n     * asynchronously.\n     * {Function}[loadedCallback] : Called when both affData and wordsData\n     * have been loaded.Only used if asyncLoad is set to true.The parameter\n     * is the instantiated Typo object.\n     */\n    constructor(dictionary, affData, wordsData, settings) {\n        this.ERR_NOT_LOAD = \"Dictionary not loaded\";\n        this.ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n        this.lDictionary = '';\n        /**\n        * Object that will contain and entry of IRuleCodes for each\n        * dynamically added key\n        */\n        this.rules = {};\n        // dictionaryTable seems to be an object full or arrays for elements in the dom.\n        this.dictionaryTable = {};\n        this.compoundRules = [];\n        this.compoundRuleCodes = {};\n        this.replacementTable = new Array();\n        this.memoized = {};\n        this.loaded = false;\n        this.options = settings || { flags: {} };\n        if (settings !== undefined && settings !== null) {\n            if (settings.flags !== undefined) {\n                this.flags = settings.flags;\n            }\n            else {\n                this.flags = {};\n            }\n        }\n        else {\n            this.flags = {};\n        }\n        const readDataFile = (url) => {\n            const response = this._readFile(url, null);\n            return response;\n            // response.then(text => {\n            // \tsetFunc(text);\n            // }).catch(error => {\n            // \tconsole.error(error);\n            // });\n        };\n        const init = async (dic, aff, wData) => {\n            const setAffData = (data) => {\n                aff = data;\n                if (wData) {\n                    setup();\n                }\n            };\n            const setWordsData = (data) => {\n                wData = data;\n                if (aff) {\n                    setup();\n                }\n            };\n            const setup = () => {\n                if (!aff) {\n                    return;\n                }\n                if (!wData) {\n                    return;\n                }\n                this.rules = this._parseAFF(aff);\n                // Save the rule codes that are used in compound rules.\n                this.compoundRuleCodes = {};\n                for (const rule of this.compoundRules) {\n                    if (typeof rule === 'string') {\n                        for (let j = 0; j < rule.length; j++) {\n                            this.compoundRuleCodes[rule.charAt(j)] = [];\n                        }\n                    }\n                }\n                // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n                // will do the work of saving the list of words that are compound-only.\n                if (this.flags.ONLYINCOMPOUND) {\n                    this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = [];\n                }\n                this.dictionaryTable = this._parseDIC(wData);\n                // Get rid of any codes from the compound rule codes that are never used\n                // (or that were special regex characters).  Not especially necessary...\n                for (const iKey in this.compoundRuleCodes) {\n                    if (Object.prototype.hasOwnProperty.call(this.compoundRuleCodes, iKey)) {\n                        if (this.compoundRuleCodes[iKey].length === 0) {\n                            delete this.compoundRuleCodes[iKey];\n                        }\n                    }\n                }\n                // Build the full regular expressions for each compound rule.\n                // I have a feeling (but no confirmation yet) that this method of\n                // testing for compound words is probably slow.\n                i = 0;\n                for (const ruleText of this.compoundRules) {\n                    let expressionText = \"\";\n                    if (typeof ruleText === 'string') {\n                        for (const character of ruleText) {\n                            if (character in this.compoundRuleCodes) {\n                                expressionText += \"(\" + this.compoundRuleCodes[character].join(\"|\") + \")\";\n                            }\n                            else {\n                                expressionText += character;\n                            }\n                        }\n                        this.compoundRules[i] = new RegExp(expressionText, \"i\");\n                        i++;\n                    }\n                }\n            };\n            const isChromeExt = () => {\n                if (typeof window.chrome?.runtime?.getURL === 'function') {\n                    return true;\n                }\n                return false;\n            };\n            const isBrowserExt = () => {\n                if (typeof window.browser?.runtime?.getURL === 'function') {\n                    return true;\n                }\n                return false;\n            };\n            let path;\n            let pLoadDataAff;\n            let pLoadDataDic;\n            // Loop-control variables.\n            let i;\n            if (dic) {\n                this.lDictionary = dic;\n                // If the data is preloaded, just setup the Typo object.\n                if (aff && wData) {\n                    setup();\n                }\n                // Loading data for Browser extentions.\n                else if (typeof window !== 'undefined' && (isChromeExt() === true || isBrowserExt() === true)) {\n                    if (this.options.dictionaryPath) {\n                        path = this.options.dictionaryPath;\n                    }\n                    else {\n                        path = \"typo/dictionaries\";\n                    }\n                    let getURL;\n                    if (isChromeExt() === true) {\n                        getURL = window.chrome.runtime.getURL;\n                    }\n                    else {\n                        getURL = window.browser.runtime.getURL;\n                    }\n                    if (!aff) {\n                        pLoadDataAff = readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".aff\"))\n                            .then(affD => {\n                            setAffData(affD);\n                        });\n                    }\n                    if (!wData) {\n                        pLoadDataDic = readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".dic\"))\n                            .then(wordsD => {\n                            setWordsData(wordsD);\n                        });\n                    }\n                }\n                else {\n                    if (this.options.dictionaryPath) {\n                        path = this.options.dictionaryPath;\n                    }\n                    else if (typeof __dirname !== 'undefined') {\n                        path = __dirname + '/dictionaries';\n                    }\n                    else {\n                        path = './dictionaries';\n                    }\n                    if (!aff) {\n                        pLoadDataAff = readDataFile(path + \"/\" + dic + \"/\" + dic + \".aff\")\n                            .then(affD => {\n                            setAffData(affD);\n                        });\n                    }\n                    if (!wData) {\n                        pLoadDataDic = readDataFile(path + \"/\" + dic + \"/\" + dic + \".dic\")\n                            .then(wordsD => {\n                            setWordsData(wordsD);\n                        });\n                    }\n                }\n            }\n            return new Promise((resolve, reject) => {\n                Promise.all([pLoadDataDic, pLoadDataAff])\n                    .then(() => { resolve(true); })\n                    .catch(err => { reject(err); });\n            });\n        };\n        this.readyPromise = new Promise((resolve, reject) => {\n            init(dictionary, affData, wordsData)\n                .then(() => {\n                resolve(this);\n            })\n                .catch((err) => {\n                reject(err);\n            });\n        });\n        if (this.options.loadedCallback) {\n            this.ready.then();\n        }\n    }\n    //#endregion Constructor\n    //#region  Properties\n    get ready() {\n        const doCallBacks = (err, t) => {\n            if (this.options.loadedCallback) {\n                if (typeof this.options.loadedCallback === 'function') {\n                    this.options.loadedCallback(err, t);\n                }\n                else if (typeof this.options.loadedCallback === 'object') {\n                    this.options.loadedCallback.forEach(fn => {\n                        fn(err, t);\n                    });\n                }\n            }\n        };\n        return this.readyPromise.then(() => {\n            this.loaded = true; // store the result\n            doCallBacks(null, this);\n            return this; // this is what makes the one-liner possible!\n        })\n            .catch(err => {\n            doCallBacks(err, this);\n            throw err;\n        });\n    }\n    get dictionary() {\n        if (this.lDictionary === '') {\n            return null;\n        }\n        return this.lDictionary;\n    }\n    //#endregion properties\n    /**\n     * Loads a Typo instance from a hash of all of the Typo properties.\n     *\n     * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n     */\n    load(obj) {\n        for (const i in obj) {\n            if (obj.hasOwnProperty(i) && Object(this).hasOwnProperty(i)) {\n                const val = obj[i];\n                Object.defineProperty(this, i.toString(), {\n                    value: val,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n                // this[i] = obj[i];\n            }\n        }\n        return this;\n    }\n    // #region _readFile function\n    /**\n     * Read the contents of a file.\n     *\n     * @param {String} path The path (relative) to the file.\n     * @param {String|null} charset The expected charset of the file, If null default to utf8\n     * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n     * files are read synchronously.\n     * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n     * always returned.\n     */\n    _readFile(path, charset) {\n        charset = charset || \"utf8\";\n        if (typeof window !== 'undefined') {\n            const requestHeaders = new Headers();\n            requestHeaders.set('Content-Type', \"text/plain; charset=\" + charset);\n            return fetch(path, {\n                method: 'GET',\n                headers: requestHeaders\n            }).then((response) => response.text());\n            ;\n        }\n        else if (typeof require !== 'undefined') { // Node.js\n            const fs = require(\"fs\");\n            let result = '';\n            let err = null;\n            try {\n                if (fs.existsSync(path)) {\n                    result = fs.readFileSync(path, charset);\n                }\n                else {\n                    throw new Error(\"Path \" + path + \" does not exist.\");\n                }\n            }\n            catch (e) {\n                err = e;\n            }\n            if (err !== null) {\n                return Promise.reject(err);\n            }\n            return Promise.resolve(result);\n        }\n        return Promise.reject(new Error('An Error occured getting dictionary'));\n    }\n    // #endregion _readFile function\n    // #region _parseAFF\n    _parseAFF(data) {\n        const rules = {};\n        let line;\n        let subline;\n        let numEntries;\n        let lineParts;\n        let i;\n        let j = 0;\n        let iLen = 0;\n        let jLen = 0;\n        // Remove comment lines\n        data = this._removeAffixComments(data);\n        const lines = data.split(/\\r?\\n/);\n        iLen = lines.length;\n        for (i = 0; i < iLen; i++) {\n            line = lines[i];\n            const definitionParts = line.split(/\\s+/);\n            const ruleType = definitionParts[0].toUpperCase();\n            if (ruleType === \"PFX\" || ruleType === \"SFX\") {\n                const ruleCode = definitionParts[1];\n                const combineable = definitionParts[2].toUpperCase();\n                numEntries = parseInt(definitionParts[3], 10);\n                const entries = [];\n                if (isNaN(numEntries) === false) {\n                    for (j = i + 1, jLen = i + 1 + numEntries; j < jLen; j++) {\n                        subline = lines[j];\n                        lineParts = subline.split(/\\s+/);\n                        const charactersToRemove = lineParts[2];\n                        const additionParts = lineParts[3].split(\"/\");\n                        let charactersToAdd = additionParts[0];\n                        if (charactersToAdd === \"0\") {\n                            charactersToAdd = \"\";\n                        }\n                        const continuationClasses = this.parseRuleCodes(additionParts[1]);\n                        const regexToMatch = lineParts[4];\n                        const entry = {\n                            add: charactersToAdd\n                        };\n                        if (continuationClasses.length > 0) {\n                            entry.continuationClasses = continuationClasses;\n                        }\n                        if (regexToMatch !== \".\") {\n                            if (ruleType === \"SFX\") {\n                                entry.match = new RegExp(regexToMatch + \"$\");\n                            }\n                            else {\n                                entry.match = new RegExp(\"^\" + regexToMatch);\n                            }\n                        }\n                        if (charactersToRemove.toString() !== \"0\") {\n                            if (ruleType === \"SFX\") {\n                                entry.remove = new RegExp(charactersToRemove + \"$\");\n                            }\n                            else {\n                                // in original Typo.js this was added as string\n                                // entry.remove = charactersToRemove;\n                                entry.remove = new RegExp(charactersToRemove);\n                            }\n                        }\n                        entries.push(entry);\n                    }\n                }\n                rules[ruleCode] = {\n                    \"type\": ruleType,\n                    \"combineable\": (combineable === \"Y\"),\n                    \"entries\": entries\n                };\n                i += numEntries;\n            }\n            else if (ruleType === \"COMPOUNDRULE\") {\n                numEntries = parseInt(definitionParts[1], 10);\n                for (j = i + 1, jLen = i + 1 + numEntries; j < jLen; j++) {\n                    line = lines[j];\n                    lineParts = line.split(/\\s+/);\n                    // When the regexp parameter is a string or a number,\n                    // it is implicitly converted to a RegExp by using new RegExp(regexp).\n                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\n                    this.compoundRules.push(lineParts[1]);\n                }\n                i += numEntries;\n            }\n            else if (ruleType === \"REP\") {\n                lineParts = line.split(/\\s+/);\n                if (lineParts.length === 3) {\n                    this.replacementTable.push([\n                        lineParts[1], lineParts[2]\n                    ]);\n                }\n            }\n            else {\n                // ONLYINCOMPOUND\n                // COMPOUNDMIN\n                // FLAG\n                // KEEPCASE\n                // NEEDAFFIX\n                this.flags[ruleType] = definitionParts[1];\n            }\n        }\n        return rules;\n    }\n    // #endregion _parseAFF\n    // #region _removeAffixComments\n    /**\n         * Removes comment lines and then cleans up blank lines and trailing whitespace.\n         *\n         * @param {String} data The data from an affix file.\n         * @return {String} The cleaned-up data.\n         */\n    _removeAffixComments(data) {\n        // Remove comments\n        // This used to remove any string starting with '#' up to the end of the line,\n        // but some COMPOUNDRULE definitions include '#' as part of the rule.\n        // I haven't seen any affix files that use comments on the same line as real data,\n        // so I don't think this will break anything.\n        const str = data.replace(/^\\s*#.*$/mg, \"\")\n            // Trim each line\n            .replace(/^\\s\\s*/m, '')\n            .replace(/\\s\\s*$/m, '')\n            // Remove blank lines.\n            .replace(/\\n{2,}/g, \"\\n\")\n            // Trim the entire string\n            .replace(/^\\s\\s*/, '')\n            .replace(/\\s\\s*$/, '');\n        return str;\n    }\n    // #endregion _removeAffixComments\n    // #region _parseDIC\n    /**\n     * Parses the words out from the .dic file.\n     *\n     * @param {String} data The data from the dictionary file.\n     * @returns object The lookup table containing all of the words and\n     *                 word forms from the dictionary.\n    * The dictionary table looks similar to the folowng.\n    * Note the dictionary table can have more than 20,000 entries\n    ````js\n        var dictionaryTable = {\n            \"1\": [[\"n\", \"m\"]],\n            \"2\": [[\"n\", \"1\"]],\n            \"d\": [[\"J\", \"G\", \"V\", \"X\"]]\n            };\n     ````\n     */\n    _parseDIC(data) {\n        data = this._removeDicComments(data);\n        const lines = data.split(/\\r?\\n/);\n        const dictionaryTable = {};\n        /**\n         * Pushes a string array on dictionary table\n         * @param {strng} key The key to add or append rules to\n         * @param {string[]} rules string array of rules to add.\n         *\n         * The dictionary table looks similar to the folowng.\n         * Note the dictionary table can have more than 20,000 entries\n         ```js\n        var dictionaryTable = {\n            \"1\": [[\"n\", \"m\"]],\n            \"2\": [[\"n\", \"1\"]],\n            \"d\": [[\"J\", \"G\", \"V\", \"X\"]]\n            };\n         ```\n         */\n        const addWord = (key, rules) => {\n            if (!dictionaryTable.hasOwnProperty(key)) {\n                dictionaryTable[key] = null;\n            }\n            if (rules.length > 0) {\n                let el = dictionaryTable[key];\n                if (el === null || el === undefined) {\n                    el = [];\n                    dictionaryTable[key] = el;\n                }\n                el.push(rules);\n            }\n        };\n        // The first line is the number of words in the dictionary.\n        for (let i = 1; i < lines.length; i++) {\n            const line = lines[i];\n            if (!line) { // Ignore empty lines.\n                continue;\n            }\n            const parts = line.split(\"/\", 2);\n            const word = parts[0];\n            // Now for each affix rule, generate that form of the word.\n            if (parts.length > 1) {\n                const ruleCodesArray = this.parseRuleCodes(parts[1]);\n                // Save the ruleCodes for compound word situations.\n                if (!(this.flags.NEEDAFFIX)\n                    || (this.flags.NEEDAFFIX && ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1)) {\n                    addWord(word, ruleCodesArray);\n                }\n                const jlen = ruleCodesArray.length;\n                for (let j = 0; j < jlen; j++) {\n                    const code = ruleCodesArray[j];\n                    const rule = this.rules[code];\n                    if (rule) {\n                        const newWords = this._applyRule(word, rule);\n                        for (const newWord of newWords) {\n                            addWord(newWord, []);\n                            if (rule.combineable) {\n                                for (let k = j + 1; k < jlen; k++) {\n                                    const combineCode = ruleCodesArray[k];\n                                    const combineRule = this.rules[combineCode];\n                                    if (combineRule) {\n                                        if (combineRule.combineable && (rule.type !== combineRule.type)) {\n                                            const otherNewWords = this._applyRule(newWord, combineRule);\n                                            for (const otherNewWord of otherNewWords) {\n                                                addWord(otherNewWord, []);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (code in this.compoundRuleCodes) {\n                        this.compoundRuleCodes[code].push(word);\n                    }\n                }\n            }\n            else {\n                addWord(word.trim(), []);\n            }\n        }\n        return dictionaryTable;\n    }\n    // #endregion _parseDIC\n    // #region _removeDicComments\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from a .dic file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeDicComments(data) {\n        // I can't find any official documentation on it, but at least the de_DE\n        // dictionary uses tab-indented lines as comments.\n        // Remove comments\n        return data.replace(/^\\t.*$/mg, \"\");\n    }\n    // #endregion _removeDicComments\n    // #region _applyRule\n    _applyRule(word, rule) {\n        const entries = rule.entries;\n        let newWords = [];\n        // if (!entries) {\n        // \treturn newWords;\n        // }\n        for (const entry of entries) {\n            if (!entry.match || word.match(entry.match)) {\n                let newWord = word;\n                if (entry.remove) {\n                    newWord = newWord.replace(entry.remove, \"\");\n                }\n                if (rule.type === \"SFX\") {\n                    newWord = newWord + entry.add;\n                }\n                else {\n                    newWord = entry.add + newWord;\n                }\n                newWords.push(newWord);\n                if (entry.continuationClasses) {\n                    entry.continuationClasses.map(key => {\n                        const continuationRule = this.rules[key];\n                        if (continuationRule) {\n                            newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n                        }\n                        /*\n                    else {\n                        // This shouldn't happen, but it does, at least in the de_DE dictionary.\n                        // I think the author mistakenly supplied lower-case rule codes instead\n                        // of upper-case.\n                    }\n                    */\n                    });\n                }\n            }\n        }\n        return newWords;\n    }\n    // #endregion _applyRule\n    //#region init\n    //#endregion init\n    // #region parseRuleCodes\n    /**\n     *\n     * @param {string} textCodes\n     */\n    parseRuleCodes(textCodes) {\n        if (!textCodes || this.flags === undefined) {\n            return [];\n        }\n        else if (!(this.flags.FLAG)) {\n            return textCodes.split(\"\");\n        }\n        else if (this.flags.FLAG === \"long\") {\n            const pFlags = [];\n            for (let i = 0; i < textCodes.length; i += 2) {\n                pFlags.push(textCodes.substr(i, 2));\n            }\n            return pFlags;\n        }\n        else if (this.flags.FLAG === \"num\") {\n            return textCodes.split(\",\");\n        }\n        return [];\n    }\n    // #endregion parseRuleCodes\n    //#region check Methods\n    /**\n     * Checks whether a word or a capitalization variant exists in the current dictionary.\n     * The word is trimmed and several variations of capitalizations are checked.\n     * If you want to check a word without any changes made to it, call checkExact()\n     *\n     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n     *\n     * @param {string} aWord The word to check.\n     * @returns {boolean}\n     */\n    check(aWord) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (aWord.length === 0) {\n            return false;\n        }\n        // Remove leading and trailing whitespace\n        const trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n        if (this.checkExact(trimmedWord)) {\n            return true;\n        }\n        // The exact word is not in the dictionary.\n        if (trimmedWord.toUpperCase() === trimmedWord) {\n            // The word was supplied in all uppercase.\n            // Check for a capitalized form of the word.\n            const capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n            if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) { // Capitalization variants are not allowed for this word.\n                return false;\n            }\n            if (this.checkExact(capitalizedWord)) {\n                return true;\n            }\n        }\n        const lowercaseWord = trimmedWord.toLowerCase();\n        if (lowercaseWord !== trimmedWord) {\n            if (this.hasFlag(lowercaseWord, \"KEEPCASE\")) { // Capitalization variants are not allowed for this word.\n                return false;\n            }\n            // Check for a lowercase form\n            if (this.checkExact(lowercaseWord)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    //#endregion\n    //#region checkExact method\n    /**\n    * Checks whether a word exists in the current dictionary.\n    *\n    * @param {string} word The word to check.\n    * @returns {boolean}\n    */\n    checkExact(word) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (word.length === 0) {\n            return false;\n        }\n        const ruleCodes = this.dictionaryTable[word];\n        if (typeof ruleCodes === 'undefined') { // Check if this might be a compound word.\n            if ((this.flags.COMPOUNDMIN) && (word.length >= this.flags.COMPOUNDMIN)) {\n                for (const rule of this.compoundRules) {\n                    if (word.match(rule)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        else if (ruleCodes === null) {\n            // a null (but not undefined) value for an entry in the dictionary table\n            // means that the word is in the dictionary but has no flags.\n            return true;\n        }\n        else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n            for (const ruleCode of ruleCodes) {\n                if ((ruleCode !== null)\n                    && !(this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCode))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    //#endregion\n    //#region hasFlag\n    /**\n     * Looks up whether a given word is flagged with a given flag.\n     *\n     * @param {string} word The word in question.\n     * @param {string} strFlag The flag in question.\n     * @param {any} [wordFlags]\n     * @return {boolean}\n     */\n    hasFlag(word, strFlag, wordFlags) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        const flattenArr = (arr) => {\n            const ar = [];\n            for (const a of arr)\n                for (const s of a)\n                    ar.push(s);\n            return ar;\n        };\n        if (strFlag in this.flags) {\n            if (typeof wordFlags === 'undefined') {\n                const tableItem = this.dictionaryTable[word];\n                if (tableItem !== undefined && tableItem !== null) {\n                    wordFlags = flattenArr(tableItem); // only interested in index of a key\n                }\n                else {\n                    wordFlags = [];\n                }\n            }\n            if (wordFlags && wordFlags.indexOf(this.flags[strFlag]) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    //#endregion hasFlag\n    //#region suggest method\n    /**\n    * Returns a list of suggestions for a misspelled word.\n    *\n    * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n    * This suggestor is primitive, but it works.\n    *\n    * @param {string} word The misspelling.\n    * @param {number} [limit=5] The maximum number of suggestions to return.\n    * @returns {string[]} The array of suggestions.\n    */\n    suggest(word, limit = 5) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (this.memoized.hasOwnProperty(word)) {\n            const memoizedLimit = this.memoized[word]['limit'];\n            // Only return the cached list if it's big enough or if there weren't enough suggestions\n            // to fill a smaller limit.\n            if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n                return this.memoized[word]['suggestions'].slice(0, limit);\n            }\n        }\n        if (this.check(word))\n            return [];\n        // Check the replacement table.\n        for (const replacementEntry of this.replacementTable) {\n            if (word.indexOf(replacementEntry[0]) !== -1) {\n                const correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n                if (this.check(correctedWord)) {\n                    return [correctedWord];\n                }\n            }\n        }\n        /*\n        if (!self.alphabet) {\n            // Use the alphabet as implicitly defined by the words in the dictionary.\n            var alphaHash = {};\n            \n            for (var i in self.dictionaryTable) {\n                for (var j = 0, _len = i.length; j < _len; j++) {\n                    alphaHash[i[j]] = true;\n                }\n            }\n            \n            for (var i in alphaHash) {\n                self.alphabet += i;\n            }\n            \n            var alphaArray = self.alphabet.split(\"\");\n            alphaArray.sort();\n            self.alphabet = alphaArray.join(\"\");\n        }\n        */\n        /**\n         * Returns a hash keyed by all of the strings that can be made\n         * by making a single edit to the word (or words in) `words`\n         * The value of each entry is the number of unique ways that the\n         * resulting word can be made.\n         * @param words words Either a hash keyed by words or a string word to operate on.\n         * @param {boolean} [knownOnly=false] known_only Whether this function should ignore strings that are not in the dictionary.\n         */\n        const edits1 = (words, knownOnly = false) => {\n            const rv = {};\n            let i;\n            let j;\n            let numLen;\n            let numJlen;\n            let strEdit;\n            if (typeof words === 'string') {\n                const wrd = words;\n                words = {};\n                words[wrd] = 1;\n            }\n            for (const wrd in words) {\n                if (Object.prototype.hasOwnProperty.call(words, wrd)) {\n                    // const wd = words[wd];\n                    for (i = 0, numLen = wrd.length + 1; i < numLen; i++) {\n                        const strSub = [wrd.substring(0, i), wrd.substring(i)];\n                        if (strSub[1]) {\n                            strEdit = strSub[0] + strSub[1].substring(1);\n                            if (!knownOnly || this.check(strEdit)) {\n                                if (!(strEdit in rv)) {\n                                    rv[strEdit] = 1;\n                                }\n                                else {\n                                    rv[strEdit] += 1;\n                                }\n                            }\n                        }\n                        // Eliminate transpositions of identical letters\n                        if (strSub[1].length > 1 && strSub[1][1] !== strSub[1][0]) {\n                            strEdit = strSub[0] + strSub[1][1] + strSub[1][0] + strSub[1].substring(2);\n                            if (!knownOnly || this.check(strEdit)) {\n                                if (!(strEdit in rv)) {\n                                    rv[strEdit] = 1;\n                                }\n                                else {\n                                    rv[strEdit] += 1;\n                                }\n                            }\n                        }\n                        if (strSub[1]) {\n                            for (j = 0, numJlen = this.ALPHABET.length; j < numJlen; j++) {\n                                // Eliminate replacement of a letter by itself\n                                if (this.ALPHABET[j] !== strSub[1].substring(0, 1)) {\n                                    strEdit = strSub[0] + this.ALPHABET[j] + strSub[1].substring(1);\n                                    if (!knownOnly || this.check(strEdit)) {\n                                        if (!(strEdit in rv)) {\n                                            rv[strEdit] = 1;\n                                        }\n                                        else {\n                                            rv[strEdit] += 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (strSub[1]) {\n                            for (j = 0, numJlen = this.ALPHABET.length; j < numJlen; j++) {\n                                strEdit = strSub[0] + this.ALPHABET[j] + strSub[1];\n                                if (!knownOnly || this.check(strEdit)) {\n                                    if (!(strEdit in rv)) {\n                                        rv[strEdit] = 1;\n                                    }\n                                    else {\n                                        rv[strEdit] += 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return rv;\n        };\n        const correct = (wrd) => {\n            // Get the edit-distance-1 and edit-distance-2 forms of this word.\n            const ed1 = edits1(wrd);\n            const ed2 = edits1(ed1, true);\n            // Sort the edits based on how many different ways they were created.\n            const weightedCorrections = ed2;\n            for (const ed1word in ed1) {\n                if (!this.check(ed1word)) {\n                    continue;\n                }\n                if (ed1word in weightedCorrections) {\n                    weightedCorrections[ed1word] += ed1[ed1word];\n                }\n                else {\n                    weightedCorrections[ed1word] = ed1[ed1word];\n                }\n            }\n            let i;\n            const sortedCorrections = [];\n            for (const j in weightedCorrections) {\n                // if (Object.prototype.hasOwnProperty.call(weighted_corrections, i)) {\n                // \tsorted_corrections.push([i, weighted_corrections[i]]);\n                // }\n                if (weightedCorrections.hasOwnProperty(j)) {\n                    sortedCorrections.push([j, weightedCorrections[j]]);\n                }\n            }\n            const sorter = (a, b) => {\n                // frist eleement is the word if a and b\n                // second element of a and b is numeric values\n                const aVal = a[1];\n                const bVal = b[1];\n                if (aVal < bVal) {\n                    return -1;\n                }\n                else if (aVal > bVal) {\n                    return 1;\n                }\n                // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n                return b[0].toString().localeCompare(a[0].toString());\n            };\n            sortedCorrections.sort(sorter).reverse();\n            const rv = [];\n            let capitalizationScheme = \"lowercase\";\n            if (wrd.toUpperCase() === wrd) {\n                capitalizationScheme = \"uppercase\";\n            }\n            else if (wrd.substr(0, 1).toUpperCase() + wrd.substr(1).toLowerCase() === wrd) {\n                capitalizationScheme = \"capitalized\";\n            }\n            let workingLimit = limit;\n            for (i = 0; i < Math.min(workingLimit, sortedCorrections.length); i++) {\n                let sortString = sortedCorrections[i][0].toString();\n                let update = false;\n                if (\"uppercase\" === capitalizationScheme) {\n                    sortString = sortString.toUpperCase();\n                    update = true;\n                }\n                else if (\"capitalized\" === capitalizationScheme) {\n                    sortString = sortString.substr(0, 1).toUpperCase() + sortString.substr(1);\n                    update = true;\n                }\n                if (!this.hasFlag(sortString, \"NOSUGGEST\") && rv.indexOf(sortString) === -1) {\n                    rv.push(sortString);\n                }\n                else {\n                    // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n                    workingLimit++;\n                }\n                if (update) {\n                    sortedCorrections[i][0] = sortString;\n                }\n            }\n            return rv;\n        };\n        this.memoized[word] = {\n            'suggestions': correct(word),\n            'limit': limit\n        };\n        return this.memoized[word]['suggestions'];\n    }\n}\n","import { Typo as T } from './index';\nif (typeof window !== 'undefined' && window.Typo === undefined) {\n    window.Typo = T;\n}\n"],"names":["Typo","dictionary","affData","wordsData","settings","ERR_NOT_LOAD","ALPHABET","lDictionary","rules","dictionaryTable","compoundRules","compoundRuleCodes","replacementTable","Array","memoized","loaded","options","flags","undefined","readDataFile","url","response","_readFile","init","dic","aff","wData","setAffData","data","setup","setWordsData","_parseAFF","rule","j","length","charAt","ONLYINCOMPOUND","_parseDIC","iKey","Object","prototype","hasOwnProperty","call","i","ruleText","expressionText","character","join","RegExp","isChromeExt","window","chrome","runtime","getURL","isBrowserExt","browser","path","pLoadDataAff","pLoadDataDic","dictionaryPath","then","affD","wordsD","__dirname","Promise","resolve","reject","all","catch","err","readyPromise","loadedCallback","ready","obj","val","defineProperty","toString","value","writable","enumerable","configurable","charset","requestHeaders","Headers","set","fetch","method","headers","text","require","fs","result","existsSync","readFileSync","Error","e","line","subline","numEntries","lineParts","iLen","jLen","_removeAffixComments","lines","split","definitionParts","ruleType","toUpperCase","ruleCode","combineable","parseInt","entries","isNaN","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","match","remove","push","str","replace","_removeDicComments","addWord","key","el","parts","word","ruleCodesArray","NEEDAFFIX","indexOf","jlen","code","newWords","_applyRule","newWord","k","combineCode","combineRule","type","otherNewWords","otherNewWord","trim","map","continuationRule","concat","textCodes","FLAG","pFlags","substr","aWord","trimmedWord","checkExact","capitalizedWord","substring","toLowerCase","hasFlag","lowercaseWord","ruleCodes","COMPOUNDMIN","strFlag","wordFlags","flattenArr","arr","ar","a","s","tableItem","limit","memoizedLimit","slice","check","replacementEntry","correctedWord","edits1","words","knownOnly","rv","numLen","numJlen","strEdit","wrd","strSub","correct","ed1","ed2","weightedCorrections","ed1word","sortedCorrections","sorter","b","aVal","bVal","localeCompare","sort","reverse","capitalizationScheme","workingLimit","Math","min","sortString","update","doCallBacks","t","forEach","fn","T"],"mappings":"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"}